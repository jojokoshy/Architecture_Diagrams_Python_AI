%%{init: {"theme":"default","themeVariables": {"background":"#ffffff","fontSize":"14"}}}%%
flowchart LR

subgraph Comments [Comments / Legend]
  direction LR
  style Comments fill:#f9fafb,stroke:#e5e7eb,color:#0f172a,stroke-width:1px;
  note1["Note: This flow is triggered by Rework Action ( Exact event to be confirmed ) and will Only receive JourneyId as input. The flow is very similar to screening flow and it uses Current Draft **entities** like Screening Journey.
  In <b> Rework Flow</b> , all the previously screened entities and its adjudicated data is cleared from FenX. For Rework scenario, since the entity data may not have changed when compared to previous flow NetReveal may not re-screen the data and hence to get the data back to Fenx, we need to query NetReveal for the AlertIds already generated.
  The idea is to build re-usable Durable Activity Functions which will be orchestrated using different Orchestration Functions based on the business flow ( cancel flow, screening flow , approval flow etc)"]:::footer
end

%% Shared styles (matching AlertsFlow)
classDef step fill:#ffffff,stroke:#2b6cb0,color:#0f172a,stroke-width:1px;
classDef decision fill:#fff7ed,stroke:#d97706,color:#92400e,stroke-width:1px;
classDef loop fill:#f0f9ff,stroke:#60a5fa,color:#0f172a,stroke-width:1px;
classDef footer fill:#ffffff,stroke:none,color:#0f172a;
subgraph MainFlow ["Main Flow"]
  direction TB
  A["Receive HTTP input with **{JourneyID} {ProcessId} {BatchId}, draft {EntityID},draft {Related Entities}**"]:::step
  A --> DecryptMessage["Decrypt payload using Azure Key Vault keys. Payload contains **{allEntities}** including Related Entities. Detailed per Entity retrieval happens in the Loop before call to NetReveal "]:::step
  DecryptMessage --> ValidateRequest["Validate Request payload for required fields JourneyID, EntityID, Related Entities using Json Schema Validation"]:::step
  ValidateRequest --> ValidSchemadecision{"Is Schema Valid?"}:::decision
  ValidSchemadecision -- Yes --> SendStatus["Respond HTTP Status 202 (Accepted) to client and continue"]:::step
  ValidSchemadecision -- No --> SendError["Respond HTTP Status 400 Bad Request with validation errors and end processing"]:::step
  SendStatus --> D["Store Request payload in <b>RequestResponsePayload</b> Table in DB"]:::step
  
  CallSuperGraphAPIForBranch["Call SuperGraph API to get **{BranchIds}** and Department for the Main Entity In the Journey using **{JourneyId}** and SuperGraph API"]:::step
  D --> CallSuperGraphAPIForBranch
  CallSuperGraphAPIForBranch --> SaveBranchDepartmentToDB["Save **{BranchIds}** and Department mapping to <b>ScreeningBatch</b> Table in DB for current **{JourneyId}**, **{ProcessId}**, **{BatchId}**"]:::step
  SaveBranchDepartmentToDB --> SaveEntitiesToDB
  SaveEntitiesToDB["Save **{allEntities}** X **{BranchIds}** (e.g. if (1 MainEntity + 4 RPs) X **Number_of_Branches_of_MainEntity = 3**) **{entityId}_{BranchId}** from Initial API Request to <b>ScreeningEntity</b> Table in DB. This call will insert Multiple rows (15 rows), one per **{entityId}_{BranchId} = ScreeningEntityId , {entiyId}, {JourneyId} {ProcessId}, {BatchId}**"]:::step
  SaveEntitiesToDB --> FenX["Call FenX Association Query API with Entity ID and Journey\n  /api/association/root/**EntityId**/journey/**JourneyId**/proposedChanges/hierarchy API and get the array of deleted Entities : Return **{deletedEntities}**"]:::step
  
  FenX --> DBSaveAssociation["Save FenX Association Request / Response to <b>RequestResponsePayload</b> Table in DB"]:::step
  
  DBSaveAssociation --> LoopStart(("Loop: Entities **{allEntities}**")):::loop

  subgraph EntitiesLoop ["Loop  Entities **{allEntities}**  ( All Entities for Journey  )"]
    direction TB
    LoopStart -->  F{"If Current Entity of **{allEntities}** is in **{deletedEntities}**"}:::decision
    G["SuperGraph API to replace Query Association API associationquery/api/association/root/**entityId** with current **{entityId}** to find Related EntityIDs"]:::step
    F -- Yes --> G
    F -- No --> L["Get OrgUnit from Azure SQL DB - Branch and Department mapping"]:::step
    G --> DBSaveAssociationEntity["Save Entity Association Request Response to <b>RequestResponsePayload</b> Table in DB"]:::step
    DBSaveAssociationEntity --> H{"Check Related Entities: Check Array Size of of association query"}:::decision
    H -- No --> Inactive["Update current **{entityId}**, **{JourneyId}** in <b>ScreeningEntity</b> Table in DB with Empty Related Entities Array as **{EntityStatus}**=InActive. Should update **1 X Number_of_Branches_of_MainEntity = 3** rows"]:::step
    H -- Yes --> Active["Update current **{entityId}**, **{JourneyId}** in <b>ScreeningEntity</b> Table in DB with Related Entities Array Count >= 1 as **{EntityStatus}**=Active.Should update **1 X Number_of_Branches_of_MainEntity = 3** rows"]:::step
    Inactive --> L
    Active --> L
    L --> CallEntity["Call FenX API to get Full Entity Details for current / draft **{entityId}**"]:::step
    CallEntity --> M["Save Full Entity Details to <b>RequestResponsePayload</b> Table in DB with OrgUnit Mapping and Active/Inactive status "]:::step
    M --> SaveToFullEntitiesToScreeningEntityTable["Update Full Entity Details to <b>ScreeningEntity</b> Table in DB for current **{entityId}**, **{JourneyId}**, **{BatchId}** with OrgUnit Mapping and Active/Inactive status. Should update **1 X Number_of_Branches_of_MainEntity = 3** rows"]:::step
    SaveToFullEntitiesToScreeningEntityTable --> LoopNetRevealCallStart[("Loop: Branches **{BranchIds}** for current Entity **{entityId}**")]:::loop
    LoopNetRevealCallStart --> N["Convert JSON to XML with XSLT Transformation"]:::step
    N -->  NRCall["Call NetReveal Screening API for current **{entityId}**, **{journeyId}**, **{BranchId}**"]:::step
    NRCall --> SaveToDB["Save NetReveal Response AlertId in <b>RequestResponsePayload</b> Table in DB against current entity **{entityId}**, **{JourneyId}**, **{BatchId}**. Only for AlertsID that had a Hit or Match will be returned else No return data"]:::step
    SaveToDB --> SaveToScreeningHitTable["Save NetReveal Response AlertId in **{ScreeningHit}** Table for current entity **{entityId}, {JourneyId}, {BatchId}, {AlertIds}**. Only AlertsIDs(Could be more than One AlertId per Entity: Sanctioned or Non-Sanctioned Alert) that had a Hit or Match will be returned else No return data"]:::step
    SaveToScreeningHitTable --> BranchDecision{"More branches to process?"}:::decision
    BranchDecision -- Yes --> LoopNetRevealCallStart
    BranchDecision -- No --> Q{"More entities to process?"}:::decision
    Q -- Yes --> LoopStart
    Q -- No --> Done["Exit For Each Entity Loop"]:::step
  end

  Done --> CheckDatabaseforExistingJourney{"Check if **ReWork** by checking <b>ScreeningEntity</b> Table for same <b>**{JourneyId}**, **{ProcessId}**, **{EntityId}**</b> and a different compared to current <b>**{BatchId}**</b> "}:::decision
  CheckDatabaseforExistingJourney -- Yes ReWork **JourneyId**, **ProcessId** Different **BatchId** --> GetJourneyStartTime["Get earliest **{currentJourneyStartTime}** from <b>ScreeningBatch</b> Table for current **{JourneyId}**, **{ProcessId}**, **{EntityId}** excluding **{BatchId}**"]:::step
  CheckDatabaseforExistingJourney -- No First time JourneyId , ProcessId --> P["End process - No response sent back to FenX"]:::footer
  GetJourneyStartTime --> LoopAlertByCustomer[("Loop: All Entities")]:::loop
  LoopAlertByCustomer --> CallNRGetAlertByCustomer["Call NetReveal Get Alert By Customer API using current **{entityId}**, **{currentJourneyStartTime}**"]:::step
  CallNRGetAlertByCustomer --> SaveAlertToDB["Save NetReveal Get Alert By Customer API Response AlertId in <b>RequestResponsePayload</b> Table in DB against current entity **{entityId}**, **{JourneyId}**, **{BatchId}**"]:::step
  SaveAlertToDB --> SaveToScreeningHitDetailsTable["Save <b>ScreeningHitDetails</b> Table with current **{entityId}**, **{JourneyId}**, **{BatchId}**, **{AlertId}**, **{ScreeningStatus}**, **{ScreeningResult}**"]:::step
  SaveToScreeningHitDetailsTable --> AlertDecision{"More alerts to process?"}:::decision
  AlertDecision -- Yes --> LoopAlertByCustomer
  AlertDecision -- No --> P["End process - No response sent back to FenX"]
  P --> EndProcess["End of Rework Flow"]:::footer
end

style MainFlow stroke-dasharray: 5 5

%% Decision between main and error blocks
IfError{"if error?"}:::decision

%% Error handling block to the right
subgraph ErrorHandler ["Error handling"]
  direction TB
  EH1["Log Error to Application Insights."]:::step
  EH2["Call Receptor API with Error details with the Schema as **{ScreenOperationError}**"]:::step
  EH1 --> EH2
end

style ErrorHandler fill:#ffe6e6,stroke:#ff0000,stroke-dasharray: 5 5

%% Connections: only between blocks (not individual nodes)
MainFlow -.-> IfError
IfError -.-> ErrorHandler
Comments ~~~MainFlow