%%{init: {"theme":"default","themeVariables": {"background":"#ffffff","fontSize":"9"}}}%%
flowchart LR

%% Shared styles (matching AlertsFlow)
classDef step fill:#ffffff,stroke:#2b6cb0,color:#0f172a,stroke-width:1px;
classDef decision fill:#fff7ed,stroke:#d97706,color:#92400e,stroke-width:1px;
classDef loop fill:#f0f9ff,stroke:#60a5fa,color:#0f172a,stroke-width:1px;
classDef footer fill:#ffffff,stroke:none,color:#0f172a;
subgraph Comments [Comments / Legend]
  direction LR
  style Comments fill:#f9fafb,stroke:#e5e7eb,color:#0f172a,stroke-width:1px;
  note1["Note: This flow is triggered by Screening Journey Adaptor Calls from FenX via Hub API Gateway. The flow is very similar to Cancel flow except that it uses <b>Current / Draft Entity Data</b> instead of <b>Verified Entities</b> in Cancel Journey.
  The idea is to build re-usable Durable Activity Functions which will be orchestrated using different Orchestration Functions based on the business flow ( cancel flow, screening flow , approval flow etc)"]:::footer
end

subgraph MainFlow ["Main Flow"]
  direction TB
  A["Receive HTTP input with JourneyID, EntityID, Related Entities"]:::step
  A --> DecryptMessage["Decrypt payload using Azure Key Vault keys. Payload contains {allEntities}"]:::step
  DecryptMessage --> ValidateRequest["Validate Request payload for required fields JourneyID, EntityID, Related Entities using Json Schema Validation"]:::step
  ValidateRequest --> ValidSchemadecision{"Is Schema Valid?"}:::decision
  ValidSchemadecision -- Yes --> SendStatus["Respond HTTP Status 202 (Accepted) to client and continue"]:::step
  ValidSchemadecision -- No --> SendError["Respond HTTP Status 400 Bad Request with validation errors and end processing"]:::step
  SendStatus --> D["Store Request payload in database"]:::step
  D --> FenX["Call FenX Association Query API with Entity ID and Journey\n  /api/association/root/{EntityId}/journey/{JourneyId}/proposedChanges/hierarchy API and get the array of deleted Entities : Return {deletedEntities}"]:::step
  FenX --> DBSaveAssociation["Save FenX Association Request / Response to Database"]:::step
  DBSaveAssociation --> LoopStart(("Loop: Entities {allEntities}")):::loop

  subgraph EntitiesLoop ["Loop  Entities {allEntities}  ( All Entities for Journey  )"]
    direction TB
    LoopStart -->  F{"If Current Entity of {allEntities} is in {deletedEntities}"}:::decision
    G["Query Association API associationquery/api/association/root/{entityId} with current {entityId} to find Related EntityIDs"]:::step
    F -- Yes --> G
    F -- No --> L["Get OrgUnit from Azure SQL DB - Branch and Department mapping"]:::step
    G --> DBSaveAssociationEntity["Save Entity Association Request Response to Database"]:::step
    DBSaveAssociationEntity --> H{"Check Related Entities: Check Array Size of of assosication query"}:::decision
    H -- No --> Inactive["Mark Entities with Empty Related Entities as InActive"]:::step
    H -- Yes --> Active["Mark Entities with Related Entities Array Count >= 1 as Active"]:::step
    Inactive --> L
    Active --> L
    L --> CallEntity["Call FenX API to get Full Entity Details for current / draft {entityId}"]:::step
    CallEntity --> M["Save Full Entity Details to Database with OrgUnit Mapping and Active/Inactive status"]:::step
    M --> N["Convert JSON to XML with XSLT Transformation"]:::step
    N -->  NRCall["Call NetReveal Screening API for current {entityId}, {journeyId}, {BranchId}"]:::step
    NRCall --> SaveToDB["Save NetReveal Response AlertId in Database against current entity {entityId}, {JourneyId}, {BatchId}. Only for AlertsID that had a Hit or Match will be returned else No return data"]:::step
    SaveToDB --> Q{"More entities to process?"}:::decision
    Q -- Yes --> LoopStart
    Q -- No --> Done["Exit For Each Entity Loop"]:::step
  end

  Done --> P["End process - No response sent back to FenX"]:::footer
end

style MainFlow stroke-dasharray: 5 5

%% Decision between main and error blocks
IfError{"if error?"}:::decision

%% Error handling block to the right
subgraph ErrorHandler ["Error handling"]
  direction TB
  EH1["Log Error to Error table"]:::step
  EH2["Call Receptor API with Error details"]:::step
  EH1 --> EH2
end

style ErrorHandler fill:#ffe6e6,stroke:#ff0000,stroke-dasharray: 5 5

%% Connections: only between blocks (not individual nodes)
MainFlow -.-> IfError
IfError -.-> ErrorHandler
Comments ~~~MainFlow