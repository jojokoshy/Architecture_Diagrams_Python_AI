%%{init: {"theme":"default","themeVariables": {"background":"#ffffff","fontSize":"14"}}}%%
flowchart LR

subgraph Comments [Comments / Legend]
  direction LR
  style Comments fill:#f9fafb,stroke:#e5e7eb,color:#0f172a,stroke-width:1px;
  note1["Note: This flow is triggered by Rework Action ( Exact event to be confirmed ) and will Only receive JourneyId as input. The flow is very similar to screening flow and it uses Current Draft **entities** like Screening Journey.
  In <b> Rework Flow</b> , all the previously screened entities and its adjudicated data is cleared from FenX. For Rework scenario, since the entity data may not have changed when compared to previous flow NetReveal may not re-screen the data and hence to get the data back to Fenx, we need to query NetReveal for the AlertIds already generated.
  The idea is to build re-usable Durable Activity Functions which will be orchestrated using different Orchestration Functions based on the business flow ( cancel flow, screening flow , approval flow etc)"]:::footer
end

%% Shared styles (matching AlertsFlow)
classDef step fill:#ffffff,stroke:#2b6cb0,color:#0f172a,stroke-width:1px;
classDef decision fill:#fff7ed,stroke:#d97706,color:#92400e,stroke-width:1px;
classDef loop fill:#f0f9ff,stroke:#60a5fa,color:#0f172a,stroke-width:1px;
classDef footer fill:#ffffff,stroke:none,color:#0f172a;
subgraph MainFlow ["Main Flow"]
  direction TB
  A["Receive HTTP input with JourneyID, EntityID, Related Entities"]:::step
  A --> DecryptMessage["Decrypt payload using Azure Key Vault keys. Payload contains **{allEntities}**"]:::step
  DecryptMessage --> ValidateRequest["Validate Request payload for required fields {JourneyId}, {EntityId}, {Related Entities} using Json Schema Validation"]:::step
  ValidateRequest --> ValidSchemadecision{"Is Schema Valid?"}:::decision
  ValidSchemadecision -- Yes --> SendStatus["Respond HTTP Status 202 (Accepted) to client and continue"]:::step
  ValidSchemadecision -- No --> SendError["Respond HTTP Status 400 Bad Request with validation errors and end processing"]:::step
  SendStatus --> D["Store Request payload in <b>RequestResponsePayload</b> Table in DB"]:::step
  
  D --> GetEntitiesForCurrentJourney["Call Supergraph API to get all Entities **{allEntities}** for current Journey, just **{entityId}**,**{branchCode}**, **{EntityStatus}**"]:::step
  GetEntitiesForCurrentJourney --> SaveEntitiesToDB["Save Supergraph API Response with all Entities to <b>RequestResponsePayload</b> Table in DB"]:::step
  SaveEntitiesToDB --> SaveEntitiesToScreeningEntityTable["Insert all  Entities (Main and RP) to <b>ScreeningEntity</b> Table in DB with **{JourneyId}**, **{ProcessId}**, **{EntityId}**, **{BatchId}**, **{BranchCode}**, **{EntityStatus}**"]:::step
  SaveEntitiesToScreeningEntityTable --> FenX["Call FenX Association Query API with Entity ID and Journey\n  /api/association/root/**EntityId**/journey/**JourneyId**/proposedChanges/hierarchy API and get the array of deleted Entities : Return **{deletedEntities}**"]:::step
  
  FenX --> DBSaveAssociation["Save FenX Association Request / Response to <b>RequestResponsePayload</b> Table in DB"]:::step
  
  DBSaveAssociation --> LoopStart(("Loop: Entities **{allEntities}**")):::loop

  subgraph EntitiesLoop ["Loop  Entities **{allEntities}**  ( All Entities for Journey  )"]
    direction TB
    LoopStart -->  F{"If Current Entity of **{allEntities}** is in **{deletedEntities}**"}:::decision
    G["Query Association API associationquery/api/association/root/**entityId** with current **{entityId}** to find Related EntityIDs"]:::step
    F -- Yes --> G
    F -- No --> L["Get OrgUnit from Azure SQL DB - Branch and Department mapping"]:::step
    G --> DBSaveAssociationEntity["Save Entity Association Request Response to <b>RequestResponsePayload</b> Table in DB"]:::step
    DBSaveAssociationEntity --> H{"Check Related Entities: Check Array Size of of association query"}:::decision
    H -- No --> Inactive["Update current **{entityId}** in <b>ScreeningEntity</b> Table in DB with Empty Related Entities Array as **{EntityStatus}**=InActive"]:::step
    H -- Yes --> Active["Update current **{entityId}** in <b>ScreeningEntity</b> Table in DB with Related Entities Array Count >= 1 as **{EntityStatus}**=Active"]:::step
    Inactive --> L
    Active --> L
    L --> CallEntity["Call FenX API to get Full Entity Details for current / draft **{entityId}**"]:::step
    CallEntity --> M["Save Full Entity Details to <b>RequestResponsePayload</b> Table in DB with OrgUnit Mapping and Active/Inactive status "]:::step
    M --> SaveToFullEntitiesToScreeningEntityTable["Update Full Entity Details to <b>ScreeningEntity</b> Table in DB for current **{entityId}**, **{JourneyId}**, **{BatchId}** with OrgUnit Mapping and Active/Inactive status"]:::step
    SaveToFullEntitiesToScreeningEntityTable --> N["Convert JSON to XML with XSLT Transformation"]:::step
    N -->  NRCall["Call NetReveal Screening API for current **{entityId}**, **{journeyId}**, **{BranchId}**"]:::step
    NRCall --> SaveToDB["Save NetReveal Response AlertId in <b>RequestResponsePayload</b> Table in DB against current entity **{entityId}**, **{JourneyId}**, **{BatchId}**. Only for AlertsID that had a Hit or Match will be returned else No return data"]:::step
    
    SaveToDB --> CheckAlertScreeningStatus{"Check Alert **{ScreeningStatus}** Status from NetReveal Response for current **{entityId}**"}:::decision
    CheckAlertScreeningStatus -- No --> CheckDatabaseforExistingJourney{"Check <b>ScreeningEntity</b> Table for same <b>**{JourneyId}**, **{ProcessId}**, **{EntityId}**</b> and a different compared to current <b>**{BatchId}**</b> "}:::decision
    CheckDatabaseforExistingJourney --same **JourneyId**, **ProcessId** Different **BatchId** --> GetJourneyStartTime["Get earliest **{currentJourneyStartTime}** from <b>ScreeningBatch</b> Table for current **{JourneyId}**, **{ProcessId}**, **{EntityId}** excluding **{BatchId}**"]:::step
    CallNRGetAlertByCustomer["Call NetReveal Get Alert By Customer API using current **{entityId}**, **{currentJourneyStartTime}**"]:::step
    GetJourneyStartTime --> CallNRGetAlertByCustomer
    SaveAlertToDB["Save NetReveal Get Alert By Customer API Response AlertId in <b>RequestResponsePayload</b> Table in DB against current entity **{entityId}**, **{JourneyId}**, **{BatchId}**"]:::step
    SaveAlertToDB --> SaveToScreeningHitDetailsTable["Save <b>ScreeningHitDetails</b> Table with current **{entityId}**, **{JourneyId}**, **{BatchId}**, **{AlertId}**, **{ScreeningStatus}**, **{ScreeningResult}**"]:::step
    CallNRGetAlertByCustomer --> SaveAlertToDB
    SaveToScreeningHitTable["Save NetReveal Response AlertId in **{ScreeningHit}** Table for current entity **{entityId}, {JourneyId}, {BatchId}, {AlertIds}**. Only AlertsIDs(Could be more than One AlertId per Entity: Sanctioned or Non-Sanctioned Alert) that had a Hit or Match will be returned else No return data"]:::step

    CheckAlertScreeningStatus -- Yes -->  SaveToScreeningHitTable --> Q
    CheckDatabaseforExistingJourney -- No --> Q
    SaveToScreeningHitDetailsTable -->  Q{"More entities to process?"}:::decision
    Q -- Yes --> LoopStart
    Q -- No --> Done["Exit For Each Entity Loop"]:::step
  end

  Done --> P["End process - No response sent back to FenX"]:::footer
end

style MainFlow stroke-dasharray: 5 5

%% Decision between main and error blocks
IfError{"if error?"}:::decision

%% Error handling block to the right
subgraph ErrorHandler ["Error handling"]
  direction TB
  EH1["Log Error to <b>Error</b> table"]:::step
  EH2["Call Receptor API with Error details"]:::step
  EH1 --> EH2
end

style ErrorHandler fill:#ffe6e6,stroke:#ff0000,stroke-dasharray: 5 5

%% Connections: only between blocks (not individual nodes)
MainFlow -.-> IfError
IfError -.-> ErrorHandler
Comments ~~~MainFlow